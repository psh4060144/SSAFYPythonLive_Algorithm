# 부분집합 합 문제
# 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제.
# 예로, [-7, -3, -2, 5, 8]의 집합에서 [-3, -2, 5]는 부분집합이면서 모두 더한 값이 0이므로 이 경우 답이 참이 된다.

# 완전탐색 기법으로 부분집합 합 문제를 풀기 위해서는, 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산.
# 주어진 집합의 부분집합을 생성하는 방법

# 부분집합의 수
# 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개.
# 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.
# 단, 부분집합을 구하는 문제는 test case로 아주 큰 case가 들어오진 않는다. 왜냐? test case가 크면 부분집합의 수가 너무 많음!

# 부분집합 생성하기
# 가장 단순한 방법: 각 원소가 부분집합에 포함되었는지를 loop 이용하여 확인하고 부분집합을 생성.
a = [3, 5, 7, 9]
bit = [0, 0, 0, 0]
for i in range(2):                  # 0번 원소
    bit[0] = i
    for j in range(2):              # 1번 원소
        bit[1] = j
        for k in range(2):          # 2번 원소
            bit[2] = k
            for l in range(2):      # 3번 원소
                bit[3] = l
                s = 0               # 합 구하기(그냥)
                for m in range(4):  # 생성된 부분집합 출력
                    if bit[m]:
                        print(a[m], end = ' ')  # 예쁘게 출력
                        s += a[m]
                print(bit, s)

# 비트 연산자
# &: bit 단위로 and 연산을 수행
# |: bit 단위로 or 연산을 수행
# <<: 피연산자의 bit 열을 왼쪽으로 이동
# >>: 피연산자의 bit 열을 오른쪽으로 이동.

# << 연산자
# 1 << n : n^2   :   원소가 n개일 경우의 모든 부분집합의 갯수
#   i & (1<<j)   :   i의 j번째 bit이 1인지 아닌지 검사.

# 부분집합을 조금 더 간결하게 생성하는 방법
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)  # 원소의 갯수

for i in range(1<<n):   # 1<<n: 부분 집합의 갯수
    for j in range(n):  # 원소의 수만큼 bit을 비교.
        if i & (1<<j):  # i의 j번 bit이 1인 경우
            print(arr[j], end = ', ')  # j 출력.
    print()
print()