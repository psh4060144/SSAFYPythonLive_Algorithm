# 검색: 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업.
# 목적하는 탐색 키를 가진 항목을 찾는 것.
# 순차 검색(sequential search), 이진 검색(binary search), 해쉬(hash) 등.


# 순차 검색 (Sequential Search)

# 일렬로 되어 있는 자료를 순서대로 검색하는 방법.
# 가장 간단하고 직관적. 배열, 연결 리스트 등 순차 구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용.
# 알고리즘이 단순하여 구현하기 쉽지만, 검색 대상의 수가 많은 경우 수행 시간이 기하급수적으로 증가. 비효율적임.

# 정렬되지 않은 list의 경우

# 검색 과정:
# 1. 첫 번째 원소부터 순서대로 검색 대상과 키값이 같은 원소가 있는지 비교.
# 2. 키값이 동일한 원소를 찾으면 그 원소의 index를 반환.
# 3. 자료구조의 마지막까지 검색 대상을 찾지 못하면 실패.

# 특징
# 찾고자 하는 원소의 순서에 따라 비교 횟수가 결정됨.
# O(n).

def seq_search(a, n, key):  # 아래처럼 만들기보다 이거처럼 만드는 게 더 확장성 있고 좋음. 이걸로 기억하고 있기.
    for i in range(n):
        if a[i] == key:
            return i
    return -1


arr = [4, 9, 11, 23, 2, 19, 7]

print(seq_search(arr, len(arr), 8))

key = 11
ans = -1

for i in range(len(arr)):
    if arr[i] == key:
        ans = i

print(ans)

arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
N = 3
key = 5
ans = 0  # key가 있으면 1, 없으면 0

for row in range(N):
    for col in range(N):

        if arr[row][col] == key:
            ans = 1
            break
    # 이렇게 이중 반복문을 만들었을 때 끝까지 break를 할 수가 없다. 이럴 때 어떻게 한다? 함수를 만들어서 써야 한다.


def seq_search(arr, n, key):
    for row in range(N):
        for col in range(N):
            if arr[row][col] == key:
                ans = 1
    return 0

# 정렬되어 있는 list의 경우

# 검색 과정:
# 자료가 오름차순으로 정렬된 상태라면, 자료를 순차 검색하며 키값을 비교하여, 원소의 키값이 검색 대상의 키값보다 크면 원소가 없다는 것. 검색 종료.

# 특징
# 찾고자 하는 원소의 순서에 따라 비교 횟수가 결정됨.
# 정렬이 되어있으므로, 검색 실패를 반환하는 경우 평균 비교 횟수가 반으로 줄어든다. 그래도, 시간 복잡도에는 영향이 없다.
# O(n)


# 이진 검색 (Binary Search)

# 자료의 가운데에 있는 항목의 키값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법.
# 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 더 빠르게 검색을 수행.

# 이진 검색을 하기 위해서는 반드시 자료가 정렬된 상태여야 함.

# 검색 과정
# 1. 자료의 중앙에 있는 원소를 고름.
# 2. 중앙 원소의 값과 찾고자 하는 목표값을 비교.
# 3. 목표 값이 중앙 원소보다 크면 오른쪽 반에서 다시 검색을 수행. 작으면 왼쪽 반에서 수행.
# 4. 찾을 때까지 1~3을 반복.
# 중앙 원소: arr[(0 + N) // 2] (arr = 대상 list, N = len(list))

# 구현
# 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행.
# 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 작업이 필요.
# 즉, 자료를 삽입할 때 배열을 유지하는 위치로 집어 넣어야 한다.


def binary_search(a, N, key):  # key를 찾으면 index, 실패하면 -1을 반환.
    start = 0
    end = N - 1  # 시작점과 끝점이 주어질 때
    while start <= end:  # 검색 구간의 원소가 1개 이상인 동안 반복
        middle = (start + end) // 2  # 가운데값(기준 위치)를 인수로 설정
        if a[middle] == key:    # key값을 찾으면
            return middle       # 검색 종료
        elif a[middle] > key:   # 찾는값보다 크면
            end = middle - 1    # 왼쪽 구간 선택
        else:                   # 찾는 값보다 작으면
            start = middle + 1  # 오른쪽 구간 선택
    return -1  # 찾는 값이 없다면 검색 실패.

# 위의 예처럼 이진 검색은 기본적으로 반복구조로 이루어져 있음. 재귀함수를 이용해 만들 수도 있음.


arr = [2, 4, 7, 9, 11, 19, 23]  # 정렬된 배열을 검색할 때만 이진 검색을 사용할 수 있음.
print(binary_search(arr, len(arr), 19))
print(binary_search(arr, len(arr), 100))


# index
# database에서 유래한 용어. 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다.
# Look up table 등의 용어를 사용하기도.
# index는 키-필드만 가지고 있고 테이블의 다른 세부 항목은 가지고 있지 않기 때문에 index를 저장하는 데 필요한 디스크 공간이 작다.
# 대량의 데이터를 매번 정렬하면 프로그램의 반응이 느려질 수밖에 없음. 이러한 성능 저하 문제를 해결하기 위해 배열 index를 사용할 수 있음.
# database index는 이진 탐색 트리 구조로 되어있음.


# 선택 정렬 (Selection Sort)  # 버블 정렬과 혼용하여 사용하는 경우가 많음. 주의.
# 주어진 자료들 중 가장 작은(큰) 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식.

# 정렬 과정
# 1. 주어진 list 중 최솟값을 찾는다.
# 2. 그 값을 list의 맨 앞에 위치한 값과 교환한다.
# 3. 맨 처음 위치를 제외한 나머지 list를 대상으로 위 과정을 반복.
# O(n**2)

# 미정렬 원소가 하나 남은 상황에서는 마지막 원소가 가장 큰 값을 가지기 때문에, 실행을 종료하고 선택 정렬이 완료.


def selection_sort(a, N):
    for i in range(N-1):  # 기준위치(최솟값을 찾는 구간의 시작 index)
        min_idx = i       # 최솟값 index 초기화, 구간의 맨 앞 원소를 최소로 가정.
        for j in range(i + 1, N):
            if a[min_idx] > a[j]:  # 최소 원소 위치 갱신
                min_idx = j
        a[i] , a[min_idx] = a [min_idx], a[i]  # 구간 최솟값을 구간 맨 앞으로. if 문을 사용해 조건문을 걸어줄 필요가 없다.


arr = [10, 25, 64, 22, 11]


# bubble sort 등의 정렬보다 비용이 적다.


# 이진 검색 잘 알아두기. 선택 정렬 공부하기. 연습문제로 델타 연습하기.