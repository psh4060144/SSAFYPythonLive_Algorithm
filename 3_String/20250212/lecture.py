# 패턴 매칭 (LPS, Longest Prefix Suffix)

# 고지식한 알고리즘 (Brute Force, 완전탐색)
# 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작.


def bruteforce(p, t):       # 패턴의 등장 횟수 리턴
    N = len(t)
    M = len(p)
    i = j = 0
    while i < N and j < M:
        if t[i] != p[j]:    # 다르면
            i = i - j + 1   # i - j 비교를 시작하는 위치를 한 칸 당김
            j = 0
        else:               # 같으면
            i += 1          # 한 칸 전진해서 다시 비교
            j += 1
    if j == M:              # 끝까지 도달할 때까지 문제가 없다면
        return i - j
    else:
        return -1


def pattern_count(p, t):
    N = len(t)
    M = len(p)
    i = j = 0
    cnt = 0
    while i < N:
        if t[i] != p[j]:    # 다르면
            i = i - j + 1   # i - j 비교를 시작하는 위치를 한 칸 당김
            j = 0
        else:               # 같으면
            i += 1          # 한 칸 전진해서 다시 비교
            j += 1
        if j == M:              # 끝까지 도달할 때까지 문제가 없다면
            cnt += 1
            i = i - j + 1
            j = 0
    return cnt


t = 'TTTTTATTAATA'
p = 'AAA'

print(pattern_count(p, t))
print(bruteforce(p, t))


# Brute Force 의 시간복잡도
# 최악의 경우 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨. (M = 찾는 문자열, N = 본문 문자열)
# 비교횟수를 줄일 방법은 없을까?

#########

# KMP 알고리즘

# 불일치가 발생한 text string 의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행.
# 패턴을 전처리하여 배열 next[M] 을 구해서 잘못된 시작을 최소화함. (next[M]: 불일치가 발생했을 경우 이동할 다음 위치)
# O(M+N)

#########

# 보이어 무어 알고리즘 (Boyer-Moore Algorithm)

# 오른쪽에서 왼쪽으로 비교. 두부분의 상용 소프트웨어에서 채택하고 있는 알고리즘.
# 패턴 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 패턴의 길이만큼 이동할 수 있다.
# 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하는 경우, 패턴에서 일치하는 문자와 겹칠 때까지 이동 가능.

# 문자열 매칭 알고리즘 비교. 찾고자 하는 문자열 패턴의 길이 = m, 총 문자열 길이 = n 이라고 할 때,
# 브루트 포스: O(mn)
# 카프-라빈 알고리즘: Θ(n) (??????)
# KMP 알고리즘: Θ(n)

# 보이어-무어 알고리즘은...
# 앞의 두 매칭 알고리즘들은 텍스트 문자열의 문자를 적어도 한 번씩은 훑는다. 따라서 최선의 경우에도 Ω(n) 이 걸린다.
# but 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다. 왜? 오른쪽부터 비교하기 때문.
# 시간복잡도: 최악의 경우 Θ(mn). but 일반적으로는 Θ(n)보다 시간이 덜 든다.

# Θ: 최악의 경우 / Ω: 최선의 경우


########


# 시저 암호 (Caesar Cipher)
# 줄리어스 시저(율리우스 카이사르)가 사용했다고 하는 암호.
# 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 평행이동시킨 암호문.

# 단일 치환 암호
# 모든 문자에 서로 다른 문자를 할당한 표를 이용해 암호화하는 방법.
# 표가 없다면 복호화하기 매우 힘들다.

# bit 열 암호화
# 배타적 논리합(exclusive-or) 연산 사용.
# 평문과 키를 비교해, XOR을 적용해서 암호문을 만듦. 그대로 키를 비교해 XOR을 적용하면 원래의 문장이 도출됨.


