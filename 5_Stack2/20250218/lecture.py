# 계산기 1

# 연산 순위가 높은 연산이 앞에 와야 한다.

# 중위표기법에서 후위표기법으로 변환하는 알고리즘
# 1. 입력받은 중위표기식에서 토큰을 읽음(토큰: 모든 숫자와 연산자)
# 2. 토큰이 피연산자라면 토큰을 출력한다.
# 3. 토큰이 연산자(괄호 포함)일 때, 이 토큰이 stack 의 top 에 저장되어 있는 연산자보다 우선순위가 높으면 stack 에 push 하고,
#   그렇지 않다면 stack 의 top 의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 stack 에서 pop 한 후 토큰의 연산자를 push.
#   만약 top 에 연산자가 없으면 push.
# 4. 괄호의 경우, 먼저 계산해야 하므로 stack 에 넣을 때는 우선순위가 높아야 하지만,
#   없어질 때는 괄호 안의 연산을 마친 후에 없어져야 하므로 뺄 때의 우선순위가 낮아야 한다.

# icp: */ -> 2 | +- -> 1 | ( -> 3
# isp: */ -> 2 | +- -> 1 | ( -> 0

# 우선 중위 표기법에서 후위 표기법으로 변환한다.

# 1. 피연산자 출력.
# 2. 연산자는 우선순위 높은 애들 다 빼고 push


# 후위표기법
# 우선 순위가 높은 연산자가 먼저 나오는 방법.
# 2 + 4 * 3 의 경우, 243*+가 나온다.
# 괄호는 다른 연산자보다 먼저 계산되어야 한다. 즉, 괄호가 처리되기 전에 먼저 괄호 안의 연산자를 연산해야 함.
# 즉, 괄호를 읽을 때는 우선순위가 높은데, 이미 읽혀진 괄호는 늦게 처리되어야 한다. 우선 순위가 낮아야 한다.

# in-coming priority
icp = {'*': 2, '/': 2, '+': 1, '-': 1, '(': 3}

# in-stack priority
isp = {'*': 2, '/': 2, '+': 1, '-': 1, '(': 0}

exp = '(6 + 5 * (2 - 8) / 2'
stack = []

for ch in exp:
    # 연산자의 우선순위가 높은 게 먼저 나와야 한다.
    if ch in '0123456789':  # 읽은 게 숫자라면 즉시 출력
        print(ch, end='')
    elif ch == ')':  # 닫히는 괄호라면 여는 괄호가 나올 대까지 연산자 출력.
        while stack[-1] != '(':
            print(stack.pop(), end='')
            # 여는 괄호는 버리기
        stack.pop()
    else:  # 연산자라면 stack 에 넣어야 함. but 우선 순위가 높은 애는 빼고 넣어야 한다.
        if not stack:  # stack 이 비어있다면 그냥 입력.
            stack.append(ch)
        else:  # stack 이 비어있지 않다면
                # ch 보다 우선순위가 높거나 같은 연산자는 출력하고 stack 에 ch 를 push.
            while stack and isp[stack[-1]] >= icp[ch]:
                print(stack.pop(), end='')
            stack.append(ch)

while stack:  # 남아있는 연산자 모두 출력.
    print(stack.pop(), end='')
