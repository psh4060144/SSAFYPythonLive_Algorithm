# 카운팅 정렬(Counting Sort)
# 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘.

# 제한 사항
# 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생횟수를 기록하기 위해, 정수 항목으로 index되는 카운트의 배열을 사용하기 때문.
# 카운트를 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함.

# 시간 복잡도: O(n+k)  # n = list 길이 / k = 정수의 최댓값

'''
0 <= data[i] <= 4
'''

data = [0, 4, 1, 3, 1, 2, 4, 1]
temp = [0] * len(data)
# counts = [0] * N  # 이건 카운팅이 아니라 그냥 인덱싱이니까 안됨.
# counts = [0] * (max(data) + 1)  # 0~4까지의 칸을 만들어야 하기 때문. 근데 이건 max 함수를 돌려야 하니까 연산을 한 번 쭉 함... 시간 복잡도 상승.
counts = [0] * 5  # 그래서 가장 큰 정수를 알고 있어야 한다는 얘기.
# 카운팅 정렬은 카운팅할 칸의 갯수가 1,000,000개 이하이고, 카운팅 정렬을 쓰라는 얘기가 있는듯 할때 쓰는 게 좋다.

for i in range(len(data)):
    counts[data[i]] += 1    # 이래서 data가 정수나 정수로 표현할 수 있는 자료에만 쓸 수 있다는 거. 정수가 아니면 counts[x]에서 indexing이 될 수가 없다.
                            # data 요소 본인이 index number가 되어 숫자를 늘려나가기 때문.
for i in range(1, 5):  # range(1, max(data) + 1)  # 처음부터 counts[i]까지의 합계. = 재귀적으로 내 전 꺼랑 나만 더하면 됨.
    counts[i] += counts[i-1]

for i in range(len(data) - 1, 0, -1):   # 근데 왜 거꾸로 하지? 앞에서 해도 될 것 같은데. 왜냐? 순서가 바뀌지 않기 때문에.
                                        # 앞에서 하면 중복값의 경우 앞의 값이 뒤로 가고 뒤의 값이 앞으로 간다!
    counts[data[i]] -= 1
    temp[counts[data[i]]] = data[i]

print(temp)

# vs Bubble Sort
# Bubble Sort: 평균 O(n^2), 최악 O(n^2). 코딩이 제일 쉽다.
# Counting Sort: 평균 O(n+k), 최악 O(n+k). n이 비교적 작을 때만 가능.