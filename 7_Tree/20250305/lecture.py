# 이진 탐색 트리
# 탐색 작업을 효율적으로 하기 위한 자료 구조.
# 모든 원소는 서로 다른 유일한 키를 갖는다. 왼쪽 서브트리의 key < root node 의 key < 오른쪽 서브트리의 key
# 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리.
# 중위순회하면 오름차순으로 정렬된 값을 얻을 수 있음.

# 탐색 연산
# root 에서 시작.
# 탐색할 키 값 x 를 root node 의 키 값과 비교.
# x < root : 왼쪽 서브트리로 이동. / x = root : 탐색 완료 / x > root : 오른쪽 서브트리로 이동
# 이 작업을 반복.

# 삽입 연산
# 먼저 탐색 연산을 수행. 왜? 같은 원소가 있다면 삽입할 수 없으니까.
# 탐색에서 탐색 실패 위치에 삽입하면 된다.

# 삭제 연산
# 먼저 탐색 연산을 수행. 왜? 무슨 원소 삭제할지는 얘기해줘야지.
# 탐색해서 같은 원소를 찾는다면 삭제.
# but, 자식이 있는 node 를 삭제하는 건 쉽지 않다.

# 이진 탐색 트리의 성능
# 탐색, 삽입, 삭제 시간이 트리의 높이만큼 걸린다. O(h).(h: binary search tree 의 깊이(height))
# 평균적인 경우(이진 트리가 균형적으로 생성되어 있는 경우) O(log n)
# 최악의 경우(한쪽으로 치우쳐진 경사 이진트리인 경우) O(n). 순차 탐색과 시간복잡도가 같다.

# 힙 heap
# 완전 이진 트리에 있는 노드 중 키값이 가장 큰 노드나 가장 작은 노드를 찾기 위해 만든 자료구조.
# 최대 힙: 키값이 가장 큰 노드를 찾기 위한 완전이진트리
### 부모 노드의 키값 > 자식 노드의 키값. 루트 노드: 키값이 가장 큰 노드
# 최소 힙: 키값이 가장 큰 노드를 찾기 위한 완전이진트리
### 부모 노드의 키값 < 자식 노드의 키값. 루트 노드: 키값이 가장 작은 노드.


def pre_order(n, N):
    # 기존 모양
    if n <= N:                  # 실존하는 정점이면    # if T:
        print(n, end=' ')                                    # visit(T)
        pre_order(n * 2, N)                            # pre_order(left[T])
        pre_order(n * 2 + 1, N)                        # pre_order(right[T])


N = 9
tree = [0, 33, 31, 27, 21, 22, 18, 23, 14, 19]
pre_order(1, N)


# heap 이 성립하는 최소 조건
# 1. 완전 이진 트리여야 한다.
# 2. 부모가 자식보다 커야 한다(최대 heap) or 부모가 자식보다 작아야 한다(최소 heap)

# heap 의 삭제
# heap 에서는 root node 의 원소만을 삭제할 수 있음.
# root node 의 원소를 삭제하여 반환한 후, heap 의 종류에 따라 최댓값 또는 최솟값을 결정할 수 있음.