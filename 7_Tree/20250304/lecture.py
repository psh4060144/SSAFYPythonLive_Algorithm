# tree
# 비선형 구조.
# 원소들 간에 1:n 관계를 가지는 자료 구조
# 원소들 간에 계층관계를 가지는 계층형 자료 구조
# 상위 원소에서 하위 원소로 내려가면서 확장되는 나무 모양의 구조.
# 일반적으로 방향성이 있다. 즉, 자식 노드에서 부모 노드로 탐색하는 일은 거의 없다.
# 한 개 이상의 노드로 이루어진 유한집합이며 다음 조건을 만족한다.
### 노드 중 최상위 노드를 root 라고 한다
### 나머지 노드들은 n(>= 0)개의 분리 집합 T1, T2, ... TN으로 분리될 수 있음.

# 용어
# 노드 node : 트리의 원소
# 간선 edge : 노드를 연결하는 선. 부모 노드와 자식 노드를 연결.
# root node : 트리의 시작 노드
# 형제 노드 : 같은 부모 노드의 자식 노드들
# 조상 노드 : 간선을 따라 root node 까지 이르는 경로에 있는 모든 노드들
# subtree : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리. 트리 내부의 트리. 프랙탈.
# 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들. 자식, 자손의 차이는 html과 같다.
# 차수
### 노드의 차수 : 노드에 연결된 자식 노드의 수.
### 트리의 차수 : 트리에 있는 노드의 차수 중 가장 큰 값.
### 단말 노드 (leaf node) : 차수가 0인 노드. 자식 노드가 없는 노드.
# 높이
### 노드의 높이 : 루트에서 노드에 이르는 간선의 수. 노드의 레벨.
### 트리의 높이 : 트리에 있는 노드의 높이 중 가장 큰 값. 최대 레벨.

# 이진 트리
# 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리
# 각 노드들이 자식 노드를 최대 2개까지만 가질 수 있음.
# 레벨 i 에서의 노드의 최대 갯수는 2 ** i 개.
# 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 갯수는 (h+1)이며, 최대 갯수는 (2 ** (h + 1) -1)개.

# 포화 이진 트리
# 모든 레벨에 노드가 포화상태로 차 있는 이진 트리.
# 높이가 h일 때 2 ** (h + 1) - 1 개의 노드를 가진 이진 트리.
# 루트를 1번으로 하여, 끝까지 정해진 위치에 대한 노드 번호를 가짐.

# 완전 이진 트리
# 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리 없이 차 있는 이진 트리.
# heap 사용 시 만날 이진 트리이므로 기억해 둘 것.

# 편향 이진 트리
# 최소 갯수의 노드를 가지면서 한 쪽 방향의 자식 노드만을 가진 이진 트리.
# 좌편향, 우편향.

# 순회
# 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말함. 트리는 비선형 구조이므로 선형 구조 처럼 선후 연결 관계를 알 수 있는 것이 아니다.
# 특별한 방법이 필요하다.
# 전위 순회, 중위 순회, 후위 순회

# 전위 순회(preorder traversal)
# VLR. 부모 노드 방문 후, 자식 노드를 좌, 우 순서로 방문한다.
# 중위 순회(inorder traversal)
# LVR. 왼쪽 자식 노드, 부모 노드, 오른쪽 자식 노드 순으로 방문한다.
# 후위 순회(postorder traversal)
# LRV. 자식 노드를 좌우 순서로 방문한 후, 부모 노드를 방문한다.
# 우 - 좌 순서로 방문하는 건 없나? 애초에 왜 좌, 우를 구분해서 하는 거지?
# 왜 좌우 구분을 해서 하는 게 아니라, 하기 편하려고 좌우 구분을 하는 것.
# 그냥 임의로 좌우 설정을 해 주는 거고, 우 좌 순서로 들르는 건 개념 상 불편하니까.

# 이진 트리의 표현
# 이진 트리의 각 노드 번호를 다음과 같이 부여할 수 있음.
# 루트 노드를 1. 레벨 n 의 노드에 대해 왼쪽부터 오른쪽까지 2 ** n ~ 2 ** (n + 1) - 1까지 번호를 부여.
# 포화 이진 트리, 완전 이진 트리에 적합함.
# 노드 번호를 배열의 index 로 사용.

# 이진 트리의 저장
# 하나의 노드 당 두 개의 노드까지만 연결되기 때문에, 배열을 두 개 만들어서 각각 저장.
# 루트 찾기, 조상 찾기: 배열의 값을 index로 넣는 작업을 반복하다 배열의 값이 0이 나오면 종료.
# 배열을 이용하면 메모리 공간이 낭비될 수 있다. 또, 중간에 새 노드를 삽입하거나 기존 노드를 삭제할 경우 배열의 크기를 변경하기 힘들다.

# 연결 리스트
# 모든 노드에 단순 연결 list를 달아준다. 3칸 짜리. 좌측, 나, 우측 이렇게.
# 이렇게 하면 메모리 낭비도 줄이고, 배열 크기 변경도 쉬움.

