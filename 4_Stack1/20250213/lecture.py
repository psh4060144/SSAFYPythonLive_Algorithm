# Stack

# 스택의 특성
# 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조.
# 스택에 저장된 자료는 선형 구조를 갖는다.
    # 선형 구조: 자료 간의 관계가 1대 1의 관계. 앞, 뒤에 있는 자료가 뭔지 얘기할 수 있다. 앞, 뒤 관계가 있다.
    # 비선형 구조: 자료 간의 관계가 1대 N의 관계(ex. Tree)
# 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
# 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(LIFO, Last In First Out). 이것도 유희왕 체인 시스템이네?????

# 스택을 프로그램에서 구현하기 위해 필요한 자료구조와 연산
# 자료구조: 자료를 선형으로 저장할 저장소. Data Structure.
    # 배열을 사용할 수 있음.
    # 저장소 자체를 스택이라고 부르기도 함.
    # 스택에서 마지막에 삽입된 원소의 위치를 top 이라고 부름. (더 일반적으로는 Stack Pointer, SP 라고 함.)
# 연산
    # 삽입: 저장소에 자료를 저장. 보통 push 라고 부름.
    # 삭제: 저장소에서 자료를 꺼냄. 꺼낸 자료는 삽입한 자료의 역순으로 꺼냄. 보통 pop 이라고 부름.
    # isEmpty: 스택이 공백인지 아닌지를 확인하는 연산
    # peek: 스택의 top 에 있는 item(원소)을 반환하는 연산.


def push(item):
    s.append(item)  # 간단한 스택의 push 알고리즘. 단, append 는 꽤나 느리다.


def push(item, size):
    global top
    top += 1
    if top == size:
        print('overflow!')  # 디버깅을 목적으로 하는 부분. 일반적인 풀이에서는 size 를 정확하게 예측해서 쓴다.
    else:
        stack[top] = item


size = 10
stack = [0] * size
top = -1

push(10, size)

top += 1
stack[top] = 20  # push(20, size) 대신 41, 42 line 으로 대체 가능. 두 line 의 순서는 바뀌어도 되지만, 웬만하면 push 함수 내부에 있는 순서대로 line 을 형성함.


def pop():
    if len(s) == 0:  # underflow
        return
    else:
        return s.pop()  # 간단한 스택의 pop 알고리즘. underflow 가 일어날 때의 예외 설정을 해야 한다.


def pop():
    global top
    if top == -1:
        print('underflow!')  # 디버깅을 목적으로 하는 부분. 일반적인 풀이에서는 size 와 top 을 예측해서 쓴다.
        return 0
    else:
        top -= 1
        return stack[top + 1]  # pop 은 웬만하면 이렇게 짜라.


print(pop())

if top > -1:  # pop() 은 일반적으로 실행하기 전 먼저 검사를 한다.
    top -= 1
    print(stack[top + 1])  # pop() 대신 65 ~ 67 line 으로 대체 가능. 66, 67 line 의 순서는 바뀌어도 되지만, 웬만하면 pop 함수 내부에 있는 순서대로 line 을 형성함.


# 스택 구현에서의 고려 사항
# 1차원 배열을 사용하여 구현할 경우 구현이 용이하지만 스택의 크기를 변경하기 힘들다(시간이 오래 걸린다).
# 이를 해결하기 위해 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다.
    # 동적 연결리스트를 이용하여 구현하는 방법.
    # 구현이 복잡하지만, 메모리를 효율적으로 사용한다.


########


# function call
# 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리.
# 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행 순서를 관리.
# 함수가 호출되면 호출한 함수 수행에 필요한 지역 변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 stack frame 에 저장하여 시스템 스택에 삽입.
# 함수 실행이 끝나면 시스템 스택의 top 원소(stack frame)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀 주소를 확인하고 복귀.
# 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백이 된다.


########


# 재귀 호출
# 필요한 함수가 자신과 같은 경우 자신을 다시 호출하는 구조
# 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출 방식보다 재귀 호출 방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성할 수 있음.
# ex. Factorial, Fibonacci...

