# 메모이제이션 (Memoization)

# 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행 속도를 높이는 것. 동적 계획법의 핵심.
# 재귀함수에서 메모이제이션을 사용하면 실행시간을 획기적으로 줄일 수 있다.


# memo 를 위한 배열을 할당하고, 모두 0으로 초기화.
# memo[0] 을 0으로 , memo[1] 은 1로 초기화.
def fibo1(n):
    global memo
    if n >= 2 and memo[n] == 0:
        memo[n] = fibo1(n - 1) + fibo1(n - 2)
    return memo[n]


memo = [0] * (n + 1)
memo[0] = 0
memo[1] = 1


# DP (Dynamic Programming, 동적 계획법)

# 최적화 문제를 해결하는 알고리즘.
# 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해를 이용하여 보다 큰 크기의 부분 문제를 해결하여, 최종적으로 원래 문제를 해결하는 알고리즘.

# 1. 문제를 부분 문제로 분할하고
# 2. 부분 문제 분할이 끝났으면 가장 작은 부분 문제부터 해를 구함
# 3. 그 결과를 table 에 저장하고, table 에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구함.

# memoization 을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP 를 구현한 것이 성능적인 면에서 더 효율적임.
# 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문.


# 비선형적인 그래프 구조를 검색하는 방법: DPS, BFS

# DPS (Depth First Search, 깊이 우선 탐색)
# 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색하다가 더 이상 갈 곳이 없게 되면 가장 마지막의 갈림길에서 다른 방향의 정점으로 탐색을 반복.
# 결국 모든 정점을 방문하는 순회방법.
# 가장 마지막 갈림길까지 되돌아가서 DPS 를 반복해야 하므로 후입선출 구조의 stack 사용.
